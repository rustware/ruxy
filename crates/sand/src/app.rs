//  Welcome to Ruxy! ðŸŽ‰
//
//  Ready to build? Head to the `routes/` directory and start hacking something great.
//
//  Want the full picture? Start here: https://ruxy.dev/docs/getting-started
//
//  Build fearlessly. Smoke benchmarks. Have fun. ðŸ¤˜

ruxy::app! {

    partytown: {
        // Experimental support for Partytown.
        // More information: https://ruxy.dev/docs/partytown
        enabled_experimental: false,
    },

    // Faster static matching for known headers, switches to `phf` when more than 30 items
    // More information: https://ruxy.dev/docs/static-matching-and-perfect-hash-function
    known_headers: {
        enabled_experimental: false,
        known_header_names: [
            "X-Test-Header",
        ],
    },

    // Faster static matching for known cookies, switches to `phf` when more than 30 items
    // More information: https://ruxy.dev/docs/static-matching-and-perfect-hash-function
    known_cookies: {
        enabled_experimental: false,
        known_cookie_names: [
            "session_id",
        ],
    },

}

// --------------- PLAYGROUND --------------- //

use bytes::Bytes;
use ruxy_runtime::response::body::ResponseBody;
use ruxy_runtime::response::buffer::ResponseBuffer;

#[expect(dead_code)]
async fn handler() -> hyper::Response<impl hyper::body::Body> {
  // Generated by the `app!` macro by comparing `<handler>::LARGEST_BYTEFRAMES_COUNT`s
  const LARGEST_BYTEFRAMES_COUNT: usize = page1::MAX_BYTEFRAMES_COUNT;
  // Generated by the `app!` macro by comparing `<handler>::SMALLEST_BYTEFRAMES_COUNT`s
  const SMALLEST_BYTEFRAMES_COUNT: usize = page2::MIN_BYTEFRAMES_COUNT;

  // max stack size for rendering in bytes
  const MAX_STACK_SIZE: usize = 300_000;
  const BUFFER_CAPACITY_SIZE: usize = size_of::<Bytes>().saturating_mul(LARGEST_BYTEFRAMES_COUNT);

  // `false` when the application emits enormous amount of Server Values and/or HTML snippets
  const USE_STACK: bool = BUFFER_CAPACITY_SIZE <= MAX_STACK_SIZE;

  let mut body: ResponseBody = ResponseBody::new();

  // For later optimization:
  let mut _rbuffer: ResponseBuffer<LARGEST_BYTEFRAMES_COUNT> = ResponseBuffer::new();

  let response = hyper::Response::builder();

  if 543 > 1 {
    // --------- Page 1 matched ---------

    // Chunk 1
    let chunk = Bytes::from_static(b"<div>");
    // SAFETY: We've pre-allocated the resp. buffer to the maximum needed
    //         size using highest <handler>::MAX_BYTEFRAMES_COUNT value.
    // unsafe { rbuffer.push_unchecked(chunk) }
    body.push(chunk);

    // Chunk 2
    let server_value = page1::page_handler().await;
    let chunk = Bytes::from(server_value);
    // SAFETY: We've pre-allocated the resp. buffer to the maximum needed
    //         size using highest <handler>::MAX_BYTEFRAMES_COUNT value.
    // unsafe { rbuffer.push_unchecked(chunk) }
    body.push(chunk);

    // Chunk 3
    let chunk = Bytes::from_static(b"</div>");
    // SAFETY: We've pre-allocated the resp. buffer to the maximum needed
    //         size using highest <handler>::MAX_BYTEFRAMES_COUNT value.
    // unsafe { rbuffer.push_unchecked(chunk) }
    body.push(chunk);
  } else {
    // --------- Page 2 matched ---------

    // Chunk 1
    let chunk = Bytes::from_static(b"<div>");
    // SAFETY: We've pre-allocated the resp. buffer to the maximum needed
    //         size using highest <handler>::MAX_BYTEFRAMES_COUNT value.
    // unsafe { rbuffer.push_unchecked(chunk) }
    body.push(chunk);

    // Chunk 2
    let server_value = page2::page_handler().await;
    let chunk = Bytes::from(server_value);
    // SAFETY: We've pre-allocated the resp. buffer to the maximum needed
    //         size using highest <handler>::MAX_BYTEFRAMES_COUNT value.
    // unsafe { rbuffer.push_unchecked(chunk) }
    body.push(chunk);

    // Chunk 3
    let chunk = Bytes::from_static(b"</div>");
    // SAFETY: We've pre-allocated the resp. buffer to the maximum needed
    //         size using highest <handler>::MAX_BYTEFRAMES_COUNT value.
    // unsafe { rbuffer.push_unchecked(chunk) }
    body.push(chunk);
  }

  // let body = ResponseBody::<LARGEST_BYTEFRAMES_COUNT> { byteframes: rbuffer };

  let response = response.body(body);

  response.unwrap()
}

// struct ResponseBody<const BYTEFRAME_CAP: usize> {
//   byteframes: ResponseBuffer<Bytes, BYTEFRAME_CAP>,
// }
//
// impl<const BYTEFRAME_CAP: usize> hyper::body::Body for ResponseBody<BYTEFRAME_CAP> {
//   type Data = Bytes;
//   type Error = ();
//
//   fn poll_frame(mut self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {
//     let Some(byteframe) = self.byteframes.consume() else {
//       return Poll::Ready(None);
//     };
//
//     Poll::Ready(Some(Ok(Frame::data(byteframe))))
//   }
//
//   fn is_end_stream(&self) -> bool {
//     self.byteframes.is_consumed()
//   }
//
//   fn size_hint(&self) -> SizeHint {
//     SizeHint::with_exact(self.byteframes.unconsumed_size())
//   }
// }

mod page1 {
  pub async fn page_handler() -> String {
    String::from("Handler 1")
  }
  // Generated by the #[page] macro inside route segment module:
  pub const MAX_BYTEFRAMES_COUNT: usize = 41;
  pub const MIN_BYTEFRAMES_COUNT: usize = 15;
}

mod page2 {
  pub async fn page_handler() -> String {
    String::from("Handler 2")
  }
  // Generated by the #[page] macro inside route segment module:
  pub const MAX_BYTEFRAMES_COUNT: usize = 23;
  pub const MIN_BYTEFRAMES_COUNT: usize = 11;
}
